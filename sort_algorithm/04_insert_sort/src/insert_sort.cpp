/***********************************************************
 * @file name: Hello_World.cpp
 * @author: liubo
 * @date: 2024.01.05
 * @describe: template
 * 
 * @expected output:
 * 
 **********************************************************/
#include<iostream>
#include <unistd.h>

using std::cin;
using std::cout;
using std::endl;

void InsertSort(int* pData,int Count) {
    int iTemp;
    int iPos;
    for(int i=1;i<Count;i++) {
        iTemp = pData[i];
        iPos = i-1;
        while((iPos>=0) && (iTemp<pData[iPos])) {
            pData[iPos+1] = pData[iPos];
            iPos--;
        }
        pData[iPos+1] = iTemp;
    }
}

int main(){
    cout << "----------------begain------------------" << endl;
    int data[] = {10,9,8,7,6,5,4};
    InsertSort(data,7);
    for (int i=0;i<7;i++) {
        cout<<data[i]<<" ";
    }

    cout<<"\n";
    cout << "----------------end------------------" << endl;
    //pause();
    return EXIT_SUCCESS;
}

/*
4.插入法：
插入法较为复杂，它的基本工作原理是抽出牌，在前面的牌中寻找相应的位置插入，然后继续下一张

i=1时：
​			iTemp=pData[1]=9
​			ipos=1-1=0;
​			ipos=0>=0 && iTemp=9<pData[0]=10;
​			pData[1]=pData[0]=10;
​			ipos--=0-1=-1;
​			pData[0]=9;  9-10-8-7-6-5-4
i=2时：
​			iTemp=pData[2]=8
​			ipos=2-1=1;
​			ipos=1>=0 && iTemp=8<pData[1]=10;
​			pData[2]=pData[1]=10;
​			ipos--=1-1=0; 9-10-10-7-6-5-4
​			ipos=0>=0 && iTemp=8<pData[0]=9;
​			pData[1]=pData[0]=9;
​			ipos--=0-1=-1;
​			pData[0]=8;  8-9-10-7-6-5-4
i=3时：
​			iTemp=pData[3]=7
​			ipos=3-1=2;
​			ipos=2>=0 && iTemp=7<pData[2]=10;
​			pData[3]=pData[2]=10;
​			ipos--=2-1=1;  8-9-10-10-6-5-4
 
​			ipos=1>=0 && iTemp=8<pData[1]=9;
​			pData[2]=pData[1]=9;
​			ipos--=1-1=0;  8-9-9-10-6-5-4
 
​			ipos=0>=0 && iTemp=7<pData[0]=8;
​			pData[1]=pData[0]=8;
​			ipos--=0-1=-1;	
​			pData[0]=7;		7-8-9-10-6-5-4i=4时:
​			iTemp=pData[4]=6;
​			ipos=4-1=3;
​			ipos=3>=0 && iTemp=6<pData[3]=10;
​			pData[4]=pData[3]=10;
​			ipos--=3-1=2; 7-8-9-10-10-5-4

​			ipos=2>=0 && iTemp=7<pData[2]=9;
​			pData[3]=pData[2]=9;
​			ipos--=2-1=1;  7-8-9-9-10-5-4

​			ipos=1>=0 && iTemp=7<pData[1]=8;
​			pData[2]=pData[1]=8;
​			ipos--=1-1=0;  7-8-8-9-10-5-4

​			ipos=0>=0 && iTemp=7<pData[0]=7;
​			pData[1]=pData[0]=7;
​			ipos--=1-1=0;  
​			pDate[0]=6;   6-7-8-9-10-5-4	

由上述可知：插入排序是先把集合中的下一个元素抽取出来
放到一个临时变量里面和第一个元素比较。并记录该元素在集合中的位置
如果第二个元素比第一个小，那么第一个元素和第二个元素对调。下一次
再用第三个元素先和变化后的第二个元素比较，如果变化后的第二个元素
小于第三个元素，用第二个元素的值覆盖第三个元素。在从临时变量里面
取出该元素放到第二个元素中去。

倒序(最糟情况)
第一轮：10,9,8,7->9,10,8,7(交换1次)(循环1次)
第二轮：9,10,8,7->8,9,10,7(交换1次)(循环2次)
第一轮：8,9,10,7->7,8,9,10(交换1次)(循环3次)
循环次数：6次
交换次数：3次

其他：
第一轮：8,10,7,9->8,10,7,9(交换0次)(循环1次)
第二轮：8,10,7,9->7,8,10,9(交换1次)(循环2次)
第一轮：7,8,10,9->7,8,9,10(交换1次)(循环1次)
循环次数：4次
交换次数：2次

上面结尾的行为分析事实上造成了一种假象，让我们认为这种算法是简单算法中最好的，
其实不是，因为其循环次数虽然并不固定，我们仍可以使用O方法。
从上面的结果可以看出，循环的次数f(n)<=1/2*n*(n-1)<=1/2*n*n。
所以其复杂度仍为O(n*n)（这里说明一下，其实如果不是为了展示这些简单排序的不同，交换次数仍然可以这样推导）。
现在看交换，从外观上看，交换次数是O(n)（推导类似选择法），但我们每次要进行与内层循环相同次数的‘=’操作。
正常的一次交换我们需要三次‘=’而这里显然多了一些，所以我们浪费了时间。

最终，我个人认为，在简单排序算法中，选择法是最好的。

*/