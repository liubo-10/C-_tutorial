/***********************************************************
 * @file name: bubble_sort.cpp
 * @author: liubo
 * @date: 2024.01.25
 * @describe: template
 * 
 * @expected output:
 * 
 **********************************************************/
#include<iostream>
#include <unistd.h>

using std::cin;
using std::cout;
using std::endl;

void BubbleSort(int* pData,int Count) {
    int iTemp;
    for(int i=1; i<Count; i++) {
        for(int j=Count-1; j>=i; j--) {
            if(pData[j]<pData[j-1]) {
                iTemp = pData[j-1];
                pData[j-1] = pData[j];
                pData[j] = iTemp;
            }
        }
    }

}

int main(){
    cout << "----------------begain------------------" << endl;

    int data[] = {10,9,8,7,6,5,4};
    BubbleSort(data,7);
    for (int i=0;i<7;i++) {
        cout<<data[i]<<" ";
    }
    cout<<"\n";

    cout << "----------------end------------------" << endl;
    //pause();
    return EXIT_SUCCESS;
}


/*
1.冒泡法：
这是最原始，也是众所周知的最慢的算法了。他的名字的由来因为它的工作看来象是冒泡：

图示： before_compare|one_turn|two_turn|three_turn|four_turn|five_turn|six_turn
10     10     10     10     10      10    4
9       9      9      9      9       4   10
8       8      8      8      4       9    9
7       7      7      4      8       8    8
6       6      4      7      7       7    7
5       4      6      6      6       6    6
4       5      5      5      5       5    5

通过上图可以看出，冒泡法形象的描述来，4这个元素就像一个气泡逐渐冒到上面来了。
我们排序的有7个元素，最坏的情况全部倒序，4这个元素要冒上来需要6次。
因此，n个元素，最坏的情况，需要移动：1+2+3+ ...+(n-1)=1/2*n(n-1)次。倒序(最糟情况)

第一轮：10,9,8,7->10,9,7,8->10,7,9,8->7,10,9,8(交换3次)
第二轮：7,10,9,8->7,10,8,9->7,8,10,9(交换2次)
第一轮：7,8,10,9->7,8,9,10(交换1次)
循环次数：6次
交换次数：6次

其他：
第一轮：8,10,7,9->8,10,7,9->8,7,10,9->7,8,10,9(交换2次)
第二轮：7,8,10,9->7,8,10,9->7,8,10,9(交换0次)
第一轮：7,8,10,9->7,8,9,10(交换1次)
循环次数：6次
交换次数：3次

上面我们给出了程序段，现在我们分析它：
这里，影响我们算法性能的主要部分是循环和交换，显然，次数越多，性能就越差。
从上面的程序我们可以看出循环的次数是固定的，为1+2+...+n-1。
写成公式就是1/2*(n-1)*n。现在注意，我们给出O方法的定义：

若存在一常量K和起点n0，使当n>=n0时，有f(n)<=K*g(n),则f(n) = O(g(n))。
（呵呵，不要说没学好数学呀，对于编程数学是非常重要的！！！）

现在我们来看1/2*(n-1)*n，当K=1/2，n0=1，g(n)=n*n时，1/2*(n-1)*n<=1/2*n*n=K*g(n)。
所以f(n)=O(g(n))=O(n*n)。所以我们程序循环的复杂度为O(n*n)。

再看交换。从程序后面所跟的表可以看到，两种情况的循环相同，交换不同。
其实交换本身同数据源的有序程度有极大的关系，当数据处于倒序的情况时，
交换次数同循环一样（每次循环判断都会交换），复杂度为O(n*n)。
当数据为正序，将不会有交换。复杂度为O(0)。乱序时处于中间状态。
正是由于这样的原因，我们通常都是通过循环次数来对比算法。


*/


